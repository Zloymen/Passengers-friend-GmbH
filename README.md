
модуль состоит из 3 частей:

 - producer, дробит исходную информацию на задачи и записывает их в MQ, порционно.  
 
 - MQ, выбрал RabbitMQ
  
 - executor, производит трансформацию данных рейса и записывает в выходную таблицу 

предустановка:

    таблица исходных(aenaflight_2017_01) данных должна находиться в database/user/password: ff/ff/ff
    
    скрипт выходной таблицы(aenaflight_source) выполнен в БД.
    
    для нормального функционирования у таблицы исходных данных должен быть индекс по следующим полям: flight_code, flight_number.
    CREATE INDEX aenaflight_source_flight_code_flight_number_index ON public.aenaflight_source (flight_code, flight_number);
    Иначе обработка 1 задачи будет иметь больщую величину, что в принципе не влияет на систему, кроме времени обработки информации.
    
    Скачать и установить rabbitMQ, я использовал docker.
    docker pull rabbitmq:3.7.7-management
    docker run -d --hostname my-rabbit --name some-rabbit -p 8999:15672 -p 5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.7.7-management


Каждая часть системы можеть быть расширена в ширину, добавлен еще один инстанс и разнесена в разные места.
Система в целом не ломается от отказа какой-то её части. Система имеет низкий порог для поддержки и расширения, т.к. 
довольно проста в целом.

Недостатки: 

        - Не совсем верно подобран MQ, RabbitMQ не может делать пакетную рассылку сообщений, из-за этого возникают колизии в виде дублирования сообщений при возникновении проблем в работе producer.(можно решить с помощью замены MQ на Kafka, но это не точно)
        - Не реализован перенос проблемных задач в Dead letter очередь.
        - Не реализовано логирование(система распределенная можно использовать что-то типа Kibana).    
        - не сделано возможность передачи параметров запуска через параметры командной строки.
    
P.S.
В исходных данных много не валидных данных(н.п. рейсов с плановой датой отправления на без плановой даты прилета, вообще без плановых дат),стоит обрать на это внимание.
В исходных данных по полям, где отсутсвуют данные записан пустой String, а не null, стоит доработать парсер сайта, данные будут занимать меньше места. 
А возможно стоит подумать над тем чтобы складывать исходные данные  другую БД(н.п. json можно легко хранить в mongoDB, на парсер не будет влиять изменение структуры ответа сайта), также это разошьет узкое место в виде БД.

Еще можно рассмотреть еще вариант исполнения данной системы в Apache Camel.
  
      

 